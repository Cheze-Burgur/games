<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>The Sweeper, by Cheze</title>
    <link rel="icon" type="image/x-icon"
        href="https://images.emojiterra.com/google/noto-emoji/unicode-15/color/512px/1f4a3.png">
    <link type="stylesheet", href="styles.css">
</head>

<body>
    <canvas id="particle-canvas"></canvas>
    <div class="center-wrap">
        <div class="wrap">
            <div class="panel">
                <header>
                    <div class="logo">ðŸ’£</div>
                    <div>
                        <h1>The Sweeper</h1>
                        <p class="lead">A Classic, by Cheze</p>
                    </div>
                </header>

                <div class="controls">
                    <div class="row">
                        <label for="difficulty" class="muted">Difficulty</label>
                        <select id="difficulty" aria-label="Select difficulty">
                            <option value="easy">Easy (9Ã—9, 10 mines)</option>
                            <option value="medium" selected>Medium (16Ã—16, 40 mines)</option>
                            <option value="hard">Hard (16Ã—30, 99 mines)</option>
                        </select>
                    </div>

                    <div class="row">
                        <button id="newGame" class="btn-primary">New Game</button>
                        <button id="resetHighscores" class="btn-ghost">Reset Highscores</button>
                    </div>

                    <div class="stats">
                        <div class="stat">
                            <strong id="mineCount">40</strong>
                            <small>Mines</small>
                            <div id="mineIcons"
                                style="margin-top:4px;display:flex;gap:2px;flex-wrap:wrap;justify-content:center;">
                            </div>
                        </div>
                        <div class="stat">
                            <strong id="flagCount">0</strong>
                            <small>Flags</small>
                        </div>
                        <div class="stat">
                            <strong id="timer">00:00</strong>
                            <small>Time</small>
                        </div>
                    </div>

                    <div class="card">
                        <div class="hs-row"><span>Best â€” Easy</span><span id="best-easy">â€”</span></div>
                        <div class="hs-row"><span>Best â€” Medium</span><span id="best-medium">â€”</span></div>
                        <div class="hs-row"><span>Best â€” Hard</span><span id="best-hard">â€”</span></div>
                    </div>

                    <footer>Left-click to reveal â€¢ Right-click to flag<br><br>Â©Cheze 2025</footer>
                </div>
            </div>

            <div class="panel board-wrap">
                <div class="game-bar">
                    <div class="smiley" id="resetBtn" title="Restart">ðŸ™‚</div>
                    <div style="flex:1"></div>
                    <div class="muted">Click a cell to begin</div>
                </div>

                <div id="boardContainer" style="width:100%;display:flex;justify-content:center;">
                    <div id="board" class="board" role="grid" aria-label="Minesweeper board"></div>
                </div>


            </div>
        </div>
    </div>

    <script>
        // --- Simple beep SFX using Web Audio API ---
        function playBeep(type) {
            const ctx = window._beepCtx || (window._beepCtx = new (window.AudioContext || window.webkitAudioContext)());
            const o = ctx.createOscillator();
            const g = ctx.createGain();
            let freq = 440, dur = 0.08, vol = 0.08;
            if (type === 'flag') { freq = 660; dur = 0.09; vol = 0.18; } // was 0.09
            if (type === 'mine') { freq = 120; dur = 0.22; vol = 0.28; } // was 0.13
            o.type = 'sine';
            o.frequency.value = freq;
            g.gain.value = vol;
            o.connect(g).connect(ctx.destination);
            o.start();
            o.stop(ctx.currentTime + dur);
        }
        /* --------- Game configuration & state --------- */
        const DIFFICULTY = {
            easy: { rows: 9, cols: 9, mines: 10 },
            medium: { rows: 16, cols: 16, mines: 40 },
            hard: { rows: 16, cols: 30, mines: 99 }
        };

        let state = {
            rows: 16, cols: 16, mines: 40, board: [], started: false, ended: false, flags: 0, revealed: 0, firstClick: true, timerInterval: null, time: 0
        };

        // DOM
        const boardEl = document.getElementById('board');
        const difficultySel = document.getElementById('difficulty');
        const mineCountEl = document.getElementById('mineCount');
        const flagCountEl = document.getElementById('flagCount');
        const timerEl = document.getElementById('timer');
        const resetBtn = document.getElementById('resetBtn');
        const newGameBtn = document.getElementById('newGame');
        const resetHsBtn = document.getElementById('resetHighscores');

        const mineIconsEl = document.getElementById('mineIcons');
        const bestEls = { easy: document.getElementById('best-easy'), medium: document.getElementById('best-medium'), hard: document.getElementById('best-hard') };


        // --- Visual mine counter ---
        function updateMineIcons() {
            if (!mineIconsEl) return;
            const minesLeft = state.mines - state.flags;
            mineIconsEl.innerHTML = '';
            for (let i = 0; i < Math.max(0, Math.min(minesLeft, 5)); i++) {
                const span = document.createElement('span');
                span.textContent = 'ðŸ’£';
                span.style.fontSize = '1.1em';
                mineIconsEl.appendChild(span);
            }
            if (minesLeft > 5) {
                const more = document.createElement('span');
                more.textContent = `+${minesLeft - 5}`;
                more.style.marginLeft = '2px';
                mineIconsEl.appendChild(more);
            }
        }

        /* ---------- Utilities ---------- */
        function formatTime(t) { const m = Math.floor(t / 60); const s = t % 60; return `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}` }
        function randInt(n) { return Math.floor(Math.random() * n) }

        /* ---------- Storage for highscores ---------- */
        function loadHighscores() {
            ['easy', 'medium', 'hard'].forEach(d => {
                const v = localStorage.getItem('ms_best_' + d);
                bestEls[d].textContent = v ? formatTime(Number(v)) : 'â€”';
            })
        }
        function saveHighscore(diff, seconds) {
            const key = 'ms_best_' + diff; const prev = localStorage.getItem(key);
            if (!prev || seconds < Number(prev)) localStorage.setItem(key, String(seconds));
            loadHighscores();
        }
        function resetHighscores() { ['easy', 'medium', 'hard'].forEach(d => localStorage.removeItem('ms_best_' + d)); loadHighscores(); }

        /* ---------- Board & game logic ---------- */
        function setDifficulty(diff) {
            const cfg = DIFFICULTY[diff];
            state.rows = cfg.rows; state.cols = cfg.cols; state.mines = cfg.mines; state.firstClick = true;
            mineCountEl.textContent = state.mines; flagCountEl.textContent = '0';
            updateMineIcons();
            updateBoardGrid();
        }

        function createEmptyBoard() {
            const b = [];
            for (let r = 0; r < state.rows; r++) {
                const row = [];
                for (let c = 0; c < state.cols; c++) {
                    row.push({ r, c, mine: false, revealed: false, flagged: false, adj: 0, el: null });
                }
                b.push(row);
            }
            state.board = b; state.revealed = 0; state.flags = 0; state.ended = false; state.started = false; state.time = 0; clearInterval(state.timerInterval);
            timerEl.textContent = '00:00';
        }

        function placeMines(avoidR, avoidC) {
            // place mines randomly but avoid cell (avoidR,avoidC) and its neighbors
            const cells = [];
            for (let r = 0; r < state.rows; r++)for (let c = 0; c < state.cols; c++)cells.push([r, c]);
            // filter out avoid + neighbors
            const banned = new Set();
            for (let rr = Math.max(0, avoidR - 1); rr <= Math.min(state.rows - 1, avoidR + 1); rr++)for (let cc = Math.max(0, avoidC - 1); cc <= Math.min(state.cols - 1, avoidC + 1); cc++)banned.add(rr + '_' + cc);
            // Fisher-Yates sample with skip
            let remaining = cells.filter(([r, c]) => !banned.has(r + '_' + c));
            for (let i = 0; i < state.mines; i++) {
                if (remaining.length === 0) break;
                const idx = randInt(remaining.length);
                const [r, c] = remaining.splice(idx, 1)[0];
                state.board[r][c].mine = true;
            }
            // compute adjacency
            for (let r = 0; r < state.rows; r++)for (let c = 0; c < state.cols; c++) {
                if (state.board[r][c].mine) continue;
                let count = 0;
                for (let dr = -1; dr <= 1; dr++)for (let dc = -1; dc <= 1; dc++) {
                    const nr = r + dr, nc = c + dc; if (nr < 0 || nc < 0 || nr >= state.rows || nc >= state.cols) continue; if (state.board[nr][nc].mine) count++;
                }
                state.board[r][c].adj = count;
            }
        }

        function revealCell(r, c) {
            if (state.ended) return;
            const cell = state.board[r][c];
            if (cell.revealed || cell.flagged) return;
            cell.revealed = true; state.revealed++;
            cell.el.classList.add('revealed');
            cell.el.classList.remove('flagged');
            if (cell.mine) {
                cell.el.classList.add('mine');
                playBeep('mine');
                endGame(false); return;
            }
            playBeep('reveal');
            if (cell.adj > 0) {
                cell.el.textContent = cell.adj; cell.el.classList.add('n' + cell.adj);
            } else {
                cell.el.textContent = ''; cell.el.classList.add('zero');
                // flood fill neighbors
                for (let dr = -1; dr <= 1; dr++)for (let dc = -1; dc <= 1; dc++) {
                    const nr = r + dr, nc = c + dc; if (nr < 0 || nc < 0 || nr >= state.rows || nc >= state.cols) continue; if (!state.board[nr][nc].revealed) revealCell(nr, nc);
                }
            }
            checkWin();
        }

        function checkWin() {
            const total = state.rows * state.cols; if (state.revealed === total - state.mines) { endGame(true); }
        }

        function endGame(won) {
            state.ended = true; clearInterval(state.timerInterval);
            if (won) {
                resetBtn.textContent = 'ðŸ˜Ž';
                // save highscore
                const diff = difficultySel.value; saveHighscore(diff, state.time);
            } else {
                resetBtn.textContent = 'ðŸ’¥';
                // reveal all mines
                for (let r = 0; r < state.rows; r++)for (let c = 0; c < state.cols; c++) {
                    const cell = state.board[r][c];
                    if (cell.mine) { cell.el.classList.add('mine'); cell.el.textContent = 'ðŸ’£'; }
                }
            }
        }

        function toggleFlag(r, c) {
            if (state.ended) return;
            const cell = state.board[r][c];
            if (cell.revealed) return;
            cell.flagged = !cell.flagged;
            if (cell.flagged) {
                cell.el.classList.add('flagged');
                cell.el.textContent = 'ðŸš©';
                state.flags++;
                playBeep('flag');
            } else {
                cell.el.classList.remove('flagged');
                cell.el.textContent = '';
                state.flags--;
            }
            flagCountEl.textContent = state.flags;
            updateMineIcons();
        }

        /* ---------- Rendering / event wiring ---------- */
        function updateBoardGrid() {
            createEmptyBoard();
            boardEl.innerHTML = '';
            updateMineIcons();
            // scale down for hard mode
            const isHard = difficultySel.value === 'hard';
            boardEl.style.gridTemplateColumns = `repeat(${state.cols}, ${isHard ? 28 : 34}px)`;
            boardEl.style.gridTemplateRows = `repeat(${state.rows}, ${isHard ? 28 : 34}px)`;
            for (let r = 0; r < state.rows; r++) {
                for (let c = 0; c < state.cols; c++) {
                    const div = document.createElement('div');
                    div.className = 'cell' + (isHard ? ' small' : '');
                    div.setAttribute('role', 'button');
                    div.setAttribute('aria-label', `Cell ${r + 1},${c + 1}`);
                    boardEl.appendChild(div);
                    state.board[r][c].el = div;
                    // left click
                    div.addEventListener('click', (e) => {
                        const cell = state.board[r][c];
                        if (cell.revealed && cell.adj > 0) {
                            // Chord: reveal all unrevealed, unflagged neighbors if flag count matches number
                            let flagCount = 0;
                            for (let dr = -1; dr <= 1; dr++) for (let dc = -1; dc <= 1; dc++) {
                                const nr = r + dr, nc = c + dc;
                                if (nr < 0 || nc < 0 || nr >= state.rows || nc >= state.cols) continue;
                                if (state.board[nr][nc].flagged) flagCount++;
                            }
                            if (flagCount === cell.adj) {
                                for (let dr = -1; dr <= 1; dr++) for (let dc = -1; dc <= 1; dc++) {
                                    const nr = r + dr, nc = c + dc;
                                    if (nr < 0 || nc < 0 || nr >= state.rows || nc >= state.cols) continue;
                                    if (!state.board[nr][nc].revealed && !state.board[nr][nc].flagged) revealCell(nr, nc);
                                }
                                return;
                            }
                        }
                        onCellClick(r, c);
                    });
                    // right click
                    div.addEventListener('contextmenu', (e) => { e.preventDefault(); toggleFlag(r, c); });

                    // --- Touch support: long-press to flag ---
                    let touchTimer = null;
                    let touchMoved = false;
                    div.addEventListener('touchstart', (e) => {
                        touchMoved = false;
                        touchTimer = setTimeout(() => {
                            toggleFlag(r, c);
                            touchTimer = null;
                        }, 400);
                    });
                    div.addEventListener('touchmove', () => {
                        touchMoved = true;
                        if (touchTimer) { clearTimeout(touchTimer); touchTimer = null; }
                    });
                    div.addEventListener('touchend', (e) => {
                        if (touchTimer) {
                            clearTimeout(touchTimer);
                            if (!touchMoved) onCellClick(r, c);
                            touchTimer = null;
                        }
                    });
                }
            }
        }

        function onCellClick(r, c) {
            if (state.ended) return;
            if (state.firstClick) {
                // place mines avoiding clicked area and neighbors
                placeMines(r, c); state.firstClick = false; startTimer(); state.started = true;
            }
            revealCell(r, c);
        }

        function startTimer() { state.timerInterval = setInterval(() => { state.time++; timerEl.textContent = formatTime(state.time); }, 1000); }

        /* ---------- wire UI ---------- */
        difficultySel.addEventListener('change', () => { setDifficulty(difficultySel.value); updateBoardGrid(); });
        newGameBtn.addEventListener('click', () => { setDifficulty(difficultySel.value); updateBoardGrid(); resetBtn.textContent = 'ðŸ™‚' })
        resetBtn.addEventListener('click', () => { setDifficulty(difficultySel.value); updateBoardGrid(); resetBtn.textContent = 'ðŸ™‚' })
        resetHsBtn.addEventListener('click', () => { if (confirm('Reset all highscores?')) { resetHighscores(); } });

        // keyboard: R resets
        document.addEventListener('keydown', (e) => { if (e.key.toLowerCase() === 'r') { setDifficulty(difficultySel.value); updateBoardGrid(); resetBtn.textContent = 'ðŸ™‚' } });

        // prevent accidental context menu on board container
        boardEl.addEventListener('contextmenu', (e) => e.preventDefault());

        // on load set default
        setDifficulty('medium'); updateBoardGrid(); loadHighscores();

        /* ---------- Particles background ---------- */
        (function particles() {
            const canvas = document.getElementById('particle-canvas'); const ctx = canvas.getContext('2d');
            let w = canvas.width = innerWidth, h = canvas.height = innerHeight; window.addEventListener('resize', () => { w = canvas.width = innerWidth; h = canvas.height = innerHeight });
            const count = Math.floor((w * h) / 80000); const particles = [];
            for (let i = 0; i < count; i++) { particles.push({ x: Math.random() * w, y: Math.random() * h * 1.2 - h * 0.2, vx: (Math.random() - 0.5) * 0.2, vy: 0.2 + Math.random() * 0.6, r: 1 + Math.random() * 3, a: 0.15 + Math.random() * 0.12 }) }
            function frame() { ctx.clearRect(0, 0, w, h); for (const p of particles) { p.x += p.vx; p.y += p.vy; if (p.y > h + 10) { p.y = -10; p.x = Math.random() * w } ctx.beginPath(); ctx.globalAlpha = p.a; ctx.fillStyle = '#bfe8ff'; ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2); ctx.fill(); } ctx.globalAlpha = 1; requestAnimationFrame(frame) }
            frame();
        })();

        /* ---------- small UX touches: adjust cell size on small screens ---------- */
        (function responsiveTune() {
            function tune() {
                const width = Math.min(window.innerWidth, 1100);
                const cellSize = width < 500 ? 28 : (width < 800 ? 32 : 34);
                const cells = document.querySelectorAll('.cell');
                cells.forEach(c => { c.style.width = cellSize + 'px'; c.style.height = cellSize + 'px'; });
                boardEl.style.gap = (cellSize > 30 ? 4 : 3) + 'px';
            }
            new ResizeObserver(tune).observe(document.body);
            tune();
        })();

    </script>
</body>

</html>