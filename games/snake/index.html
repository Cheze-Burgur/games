<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>The Snake</title>
    <link type="stylesheet", href="styles.css">
</head>

<body>
    <div class="wrap">
        <div class="card" role="application" aria-label="Snake game">
            <header>
                <div>
                    <h1>The Snake</h1>
                    <div class="sub">A Classic, by Cheze</div>
                </div>
                <div style="display:flex;gap:12px;align-items:center">
                    <div class="pill">Use arrows or WASD</div>
                    <div class="pill" id="best-pill">Best: 0</div>
                </div>
            </header>

            <section class="game-area">
                <canvas id="game" width="480" height="480" aria-label="Snake playfield"></canvas>
                <div class="grid-info">
                    <div class="pill" id="score-pill">Score: 0</div>
                    <div class="pill" id="speed-pill">Speed: Normal</div>
                </div>
            </section>

            <aside class="panel">
                <div class="stat"><span>Score</span><strong id="score">0</strong></div>
                <div class="stat"><span>Level / Grid</span><strong id="gridLabel">20 × 20</strong></div>
                <div class="stat"><span>Game state</span><strong id="stateLabel">Ready</strong></div>

                <div style="margin-top:6px">
                    <label for="difficulty">Difficulty</label>
                    <select id="difficulty">
                        <option value="easy">Easy (Slow)</option>
                        <option value="normal" selected>Normal</option>
                        <option value="hard">Hard (Fast)</option>
                    </select>
                </div>

                <div style="margin-top:10px">
                    <label for="gridSize">Grid size: <span id="gridSizeVal">20</span></label>
                    <input id="gridSize" type="range" min="10" max="40" value="20">
                </div>

                <div class="controls">
                    <button id="startBtn" class="btn-accent">Start / Resume</button>
                    <button id="pauseBtn" class="btn-ghost">Pause</button>
                    <button id="restartBtn" class="btn-ghost">Restart</button>
                </div>

                <div style="margin-top:12px">
                    <label>Touch controls</label>
                    <div style="display:flex;gap:8px;margin-top:8px">
                        <button id="upBtn" class="btn-ghost">↑</button>
                        <button id="leftBtn" class="btn-ghost">←</button>
                        <button id="downBtn" class="btn-ghost">↓</button>
                        <button id="rightBtn" class="btn-ghost">→</button>
                    </div>
                </div>

                <div style="margin-top:12px;font-size:0.9rem;color:var(--muted)">
                    <p style="margin:6px 0">High score is stored locally in your browser.</p>
                    <button id="clearHigh" class="btn-ghost">Clear High Score</button>
                </div>
            </aside>

            <div class="footer">©Cheze 2025</div>
        </div>
    </div>

    <script>
        // ----- Game constants & utilities -----
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const scorePill = document.getElementById('score-pill');
        const bestPill = document.getElementById('best-pill');
        const speedPill = document.getElementById('speed-pill');
        const gridLabel = document.getElementById('gridLabel');
        const stateLabel = document.getElementById('stateLabel');

        const startBtn = document.getElementById('startBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const restartBtn = document.getElementById('restartBtn');
        const clearHigh = document.getElementById('clearHigh');

        const difficultySelect = document.getElementById('difficulty');
        const gridSizeInput = document.getElementById('gridSize');
        const gridSizeVal = document.getElementById('gridSizeVal');

        const upBtn = document.getElementById('upBtn');
        const leftBtn = document.getElementById('leftBtn');
        const downBtn = document.getElementById('downBtn');
        const rightBtn = document.getElementById('rightBtn');

        // Local storage keys
        const HS_KEY = 'snake_highscore_v1';

        // Game state
        let gridSize = parseInt(gridSizeInput.value, 10);
        let cellSize = canvas.width / gridSize;

        let snake = [];
        let dir = { x: 1, y: 0 };
        let pendingDir = null; // to avoid reversing in one tick
        let apple = null;
        let score = 0;
        let high = Number(localStorage.getItem(HS_KEY) || 0);
        bestPill.textContent = `Best: ${high}`;

        let running = false;
        let intervalId = null;
        let tickMs = 120; // base, modified by difficulty

        // Helpers
        function setDifficulty(diff) {
            if (diff === 'easy') tickMs = 160;
            else if (diff === 'normal') tickMs = 110;
            else tickMs = 70;
            speedPill.textContent = diff[0].toUpperCase() + diff.slice(1);
        }

        function rndInt(n) { return Math.floor(Math.random() * n); }

        function posEq(a, b) { return a.x === b.x && a.y === b.y }

        // ----- Init & reset -----
        function resetGame() {
            gridSize = parseInt(gridSizeInput.value, 10);
            cellSize = canvas.width / gridSize;
            snake = [];
            // start with length 3 in center
            const mid = Math.floor(gridSize / 2);
            snake.push({ x: mid - 1, y: mid });
            snake.push({ x: mid, y: mid });
            snake.push({ x: mid + 1, y: mid });
            dir = { x: 1, y: 0 };
            pendingDir = null;
            score = 0;
            apple = null;
            spawnApple();
            scoreEl.textContent = score;
            scorePill.textContent = `Score: ${score}`;
            gridLabel.textContent = `${gridSize} × ${gridSize}`;
            gridSizeVal.textContent = gridSize;
            stateLabel.textContent = 'Ready';
            draw();
        }

        // Spawn apple not on snake
        function spawnApple() {
            let tries = 0;
            while (true) {
                const p = { x: rndInt(gridSize), y: rndInt(gridSize) };
                if (!snake.some(s => posEq(s, p))) { apple = p; break; }
                if (++tries > 1000) break; // fallback
            }
        }

        // ----- Game loop -----
        function tick() {
            if (pendingDir) {
                // prevent 180-turn: only accept if not opposite
                const opp = (pendingDir.x === -dir.x && pendingDir.y === -dir.y);
                if (!opp) { dir = pendingDir; }
                pendingDir = null;
            }

            const head = { x: snake[snake.length - 1].x + dir.x, y: snake[snake.length - 1].y + dir.y };

            // wrap around (classic) — change to wall-collision if you prefer
            if (head.x < 0) head.x = gridSize - 1;
            if (head.y < 0) head.y = gridSize - 1;
            if (head.x >= gridSize) head.x = 0;
            if (head.y >= gridSize) head.y = 0;

            // check self collision
            if (snake.some(s => posEq(s, head))) {
                gameOver();
                return;
            }

            snake.push(head);

            // ate apple?
            if (posEq(head, apple)) {
                score += 1;
                scoreEl.textContent = score;
                scorePill.textContent = `Score: ${score}`;
                spawnApple();
            } else {
                snake.shift(); // move
            }

            draw();
        }

        function start() {
            if (running) return;
            setDifficulty(difficultySelect.value);
            running = true;
            stateLabel.textContent = 'Running';
            if (intervalId) clearInterval(intervalId);
            intervalId = setInterval(tick, tickMs);
        }

        function pause() {
            running = false;
            stateLabel.textContent = 'Paused';
            if (intervalId) { clearInterval(intervalId); intervalId = null; }
        }

        function restart() {
            pause();
            resetGame();
            start();
        }

        function gameOver() {
            pause();
            stateLabel.textContent = 'Game Over';
            // update high score
            if (score > high) {
                high = score;
                localStorage.setItem(HS_KEY, String(high));
                bestPill.textContent = `Best: ${high}`;
            }
        }

        // ----- Rendering -----
        function draw() {
            // clear
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // draw background grid subtle
            const gap = 1;
            for (let x = 0; x < gridSize; x++) {
                for (let y = 0; y < gridSize; y++) {
                    const px = x * cellSize;
                    const py = y * cellSize;
                    ctx.fillStyle = ((x + y) % 2 === 0) ? '#071a2b' : '#05202f';
                    ctx.fillRect(px, py, cellSize - gap, cellSize - gap);
                }
            }

            // apple
            if (apple) {
                const aX = apple.x * cellSize;
                const aY = apple.y * cellSize;
                // glow
                ctx.fillStyle = '#ffb98a';
                ctx.beginPath();
                ctx.ellipse(aX + cellSize / 2, aY + cellSize / 2, cellSize * 0.42, cellSize * 0.42, 0, 0, Math.PI * 2);
                ctx.fill();
                // core
                ctx.fillStyle = 'var(--accent)';
                ctx.beginPath();
                ctx.ellipse(aX + cellSize / 2, aY + cellSize / 2, cellSize * 0.28, cellSize * 0.28, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            // snake body
            for (let i = 0; i < snake.length; i++) {
                const part = snake[i];
                const x = part.x * cellSize;
                const y = part.y * cellSize;
                const radius = Math.max(2, cellSize * 0.12);
                // head brighter
                if (i === snake.length - 1) {
                    // head with gradient
                    const g = ctx.createLinearGradient(x, y, x + cellSize, y + cellSize);
                    g.addColorStop(0, '#ffd9b8');
                    g.addColorStop(1, '#ff8a33');
                    ctx.fillStyle = g;
                } else {
                    ctx.fillStyle = '#7fb0d6';
                }
                roundRect(ctx, x + 2, y + 2, cellSize - 4, cellSize - 4, radius);
                ctx.fill();
            }

        }

        // rounded rectangle helper
        function roundRect(ctx, x, y, w, h, r) {
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.arcTo(x + w, y, x + w, y + h, r);
            ctx.arcTo(x + w, y + h, x, y + h, r);
            ctx.arcTo(x, y + h, x, y, r);
            ctx.arcTo(x, y, x + w, y, r);
            ctx.closePath();
        }

        // ----- input handling -----
        window.addEventListener('keydown', e => {
            const key = e.key;
            if (key === 'ArrowUp' || key === 'w' || key === 'W') pendingDir = { x: 0, y: -1 };
            if (key === 'ArrowDown' || key === 's' || key === 'S') pendingDir = { x: 0, y: 1 };
            if (key === 'ArrowLeft' || key === 'a' || key === 'A') pendingDir = { x: -1, y: 0 };
            if (key === 'ArrowRight' || key === 'd' || key === 'D') pendingDir = { x: 1, y: 0 };

            if (key === ' ') { // space to pause/resume
                if (running) pause(); else start();
            }
            if (key === 'r' || key === 'R') restart();
        });

        // touch / click controls
        upBtn.addEventListener('click', () => pendingDir = { x: 0, y: -1 });
        downBtn.addEventListener('click', () => pendingDir = { x: 0, y: 1 });
        leftBtn.addEventListener('click', () => pendingDir = { x: -1, y: 0 });
        rightBtn.addEventListener('click', () => pendingDir = { x: 1, y: 0 });

        startBtn.addEventListener('click', start);
        pauseBtn.addEventListener('click', () => { if (running) pause(); else start(); });
        restartBtn.addEventListener('click', restart);
        clearHigh.addEventListener('click', () => { localStorage.removeItem(HS_KEY); high = 0; bestPill.textContent = `Best: ${high}`; });

        difficultySelect.addEventListener('change', () => {
            const wasRunning = running;
            pause();
            setDifficulty(difficultySelect.value);
            if (wasRunning) start();
        });

        gridSizeInput.addEventListener('input', () => {
            gridSizeVal.textContent = gridSizeInput.value;
        });

        gridSizeInput.addEventListener('change', () => {
            const wasRunning = running;
            pause();
            resetGame();
            if (wasRunning) start();
        });

        // prevent arrow keys from scrolling the page
        window.addEventListener('keydown', function (e) {
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) e.preventDefault();
        }, { passive: false });

        // resize canvas on hi-dpi screens
        function fixCanvasForHiDPI() {
            const dpr = window.devicePixelRatio || 1;
            const size = 480;
            canvas.width = size * dpr;
            canvas.height = size * dpr;
            canvas.style.width = size + 'px';
            canvas.style.height = size + 'px';
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            cellSize = canvas.width / dpr / gridSize;
        }

        window.addEventListener('resize', () => { fixCanvasForHiDPI(); draw(); });

        // initial setup
        fixCanvasForHiDPI();
        setDifficulty(difficultySelect.value);
        resetGame();

        // Accessibility: allow clicking on canvas to toggle pause
        canvas.addEventListener('click', () => { if (running) pause(); else start(); });

    </script>
</body>

</html>
